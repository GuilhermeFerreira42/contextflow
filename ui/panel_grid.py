# contextflow/ui/panel_grid.py
import wx
import wx.grid
import webbrowser
from core.processor import Processor
from storage.db_handler import DatabaseHandler

class GridPanel(wx.Panel):
    def __init__(self, parent, on_data_changed=None, log_callback=None):
        super().__init__(parent)
        self.on_data_changed = on_data_changed
        self.log_callback = log_callback
        self.db_handler = DatabaseHandler()
        
        # Processor
        self.processor = Processor()
        self.processor.on_task_update = self.on_task_update
        self.processor.on_task_complete = self.on_task_complete
        self.processor.on_error = self.on_task_error
        
        # Novos Eventos
        self.processor.on_task_queued = self.on_task_queued
        self.processor.on_task_started = self.on_task_started
        self.processor.on_metadata_fetched = self.on_metadata_fetched
        
        self.processor.start_processing() 
        
        # Mapping row -> video_id (or uuid) for easy access
        self.row_map = {} 
        
        self._init_ui()
        self.load_data()

    def _init_ui(self):
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        
        # 1. Headline
        lbl_head = wx.StaticText(self, label="Dashboard (Excel View)")
        font = lbl_head.GetFont()
        font.SetPointSize(12)
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        lbl_head.SetFont(font)
        main_sizer.Add(lbl_head, 0, wx.ALL, 10)

        # 2. Input Area
        input_sizer = wx.StaticBoxSizer(wx.VERTICAL, self, "Adicionar URLs (Youtube Vídeo ou Playlist)")
        self.txt_input = wx.TextCtrl(self, style=wx.TE_MULTILINE, size=(-1, 60))
        input_sizer.Add(self.txt_input, 1, wx.EXPAND | wx.ALL, 5)
        
        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.btn_process = wx.Button(self, label="Processar Fila", size=(200, 40))
        self.btn_process.Bind(wx.EVT_BUTTON, self.on_click_process)
        
        self.btn_clear_input = wx.Button(self, label="Limpar")
        self.btn_clear_input.Bind(wx.EVT_BUTTON, lambda e: self.txt_input.Clear())

        btn_sizer.Add(self.btn_process, 0, wx.RIGHT, 5) 
        btn_sizer.Add(self.btn_clear_input, 0, wx.ALIGN_CENTER_VERTICAL)
        
        input_sizer.Add(btn_sizer, 0, wx.EXPAND | wx.ALL, 5)
        main_sizer.Add(input_sizer, 0, wx.EXPAND | wx.ALL, 5)

        # 3. Grid Table
        self.grid = wx.grid.Grid(self)
        self.grid.CreateGrid(0, 11) # Rows autogenerated, 11 Cols
        
        # Col Headers
        cols = [" [x] ", "ID", "Link", "Título", "Canal", "Publicado", "Playlist", "Duração", "Tokens", "Custo ($)", "Status"]
        for i, col in enumerate(cols):
            self.grid.SetColLabelValue(i, col)
            
        # Configurar tipos de colunas
        self.grid.SetColFormatBool(0) # Checkbox
        
        # Tamanhos
        self.grid.SetColSize(0, 40)
        self.grid.SetColSize(1, 80) # ID
        self.grid.SetColSize(2, 200) # Link
        self.grid.SetColSize(3, 300) # Title
        self.grid.SetColSize(4, 150) # Channel (New)
        self.grid.SetColSize(5, 100) # Published (New)
        self.grid.SetColSize(6, 150) # PL
        self.grid.SetColSize(7, 70) # Duration
        
        # Eventos Grid
        self.grid.Bind(wx.grid.EVT_GRID_LABEL_LEFT_CLICK, self.on_header_click)
        self.grid.Bind(wx.grid.EVT_GRID_CELL_LEFT_CLICK, self.on_cell_click)
        
        # Mouse Motion para cursor "Hand"
        self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.on_grid_motion)
        
        main_sizer.Add(self.grid, 1, wx.EXPAND | wx.ALL, 5)
        
        # 4. Footer Actions
        action_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.btn_delete = wx.Button(self, label="Excluir Selecionados")
        self.btn_delete.Bind(wx.EVT_BUTTON, self.on_delete_selected)
        
        self.btn_export = wx.Button(self, label="Exportar Selecionados (ZIP)")
        self.btn_export.Bind(wx.EVT_BUTTON, self.on_export)
        
        self.lbl_status = wx.StaticText(self, label="Pronto.")
        
        action_sizer.Add(self.lbl_status, 1, wx.ALIGN_CENTER_VERTICAL)
        action_sizer.Add(self.btn_delete, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 5)
        action_sizer.Add(self.btn_export, 0, wx.ALIGN_CENTER_VERTICAL)
        
        main_sizer.Add(action_sizer, 0, wx.EXPAND | wx.ALL, 5)
        
        self.SetSizer(main_sizer)

    def load_data(self):
        """Carrega dados iniciais do banco. CUIDADO: Limpa a grid."""
        # Limpar grid
        if self.grid.GetNumberRows() > 0:
            self.grid.DeleteRows(0, self.grid.GetNumberRows())
            
        videos = self.db_handler.get_all_videos()
        # Ordenar por data desc
        videos.sort(key=lambda x: x['created_at'], reverse=True)
        
        self.row_map = {}
        self.grid.AppendRows(len(videos))
        
        for i, v in enumerate(videos):
            self.row_map[i] = v['id']
            
            # 0: Check
            self.grid.SetCellValue(i, 0, "0")
            
            # 1: ID
            self.grid.SetCellValue(i, 1, str(v['id']))

            # 2: Link
            url = v.get('url', '')
            self.grid.SetCellValue(i, 2, url)
            if url:
                 self.grid.SetCellTextColour(i, 2, wx.BLUE) # Blue Link
            
            # 3: Title
            self.grid.SetCellValue(i, 3, v['title'] or "Sem Título")
            
            # 4: Channel
            self.grid.SetCellValue(i, 4, v.get('channel_name') or "-")

            # 5: Published
            raw_date = v.get('upload_date') or ""
            # Format YYYYMMDD -> DD/MM/YYYY
            if len(raw_date) == 8 and raw_date.isdigit():
                formatted_date = f"{raw_date[6:8]}/{raw_date[4:6]}/{raw_date[0:4]}"
                self.grid.SetCellValue(i, 5, formatted_date)
            else:
                self.grid.SetCellValue(i, 5, raw_date)

            # 6: Playlist
            self.grid.SetCellValue(i, 6, v.get('playlist_title') or "-")
            
            # 7: Duration
            d = v.get('duration')
            self.grid.SetCellValue(i, 7, str(d) if d else "0")
            
            # 8: Tokens
            t = v.get('token_count') or 0
            self.grid.SetCellValue(i, 8, str(t))
            
            # 9: Custo
            cost = t * 0.000005
            self.grid.SetCellValue(i, 9, f"{cost:.4f}")
            
            # 10: Status
            status = v.get('status', 'pending')
            self.grid.SetCellValue(i, 10, status)
            if status == "ERROR":
                 self.grid.SetCellTextColour(i, 10, wx.RED)
            else:
                 self.grid.SetCellTextColour(i, 10, wx.BLACK)
            
            # ReadOnly
            for c in range(1, 11):
                self.grid.SetReadOnly(i, c, True)

    def on_cell_click(self, event):
        row = event.GetRow()
        col = event.GetCol()
        
        # 1. Clique único no Checkbox
        if col == 0:
            val = self.grid.GetCellValue(row, 0)
            new_val = "1" if val == "0" else "0"
            self.grid.SetCellValue(row, 0, new_val)
            self.grid.ForceRefresh() 
            
        # 2. Clique no Link
        elif col == 2:
            url = self.grid.GetCellValue(row, 2)
            if url.startswith("http"):
                webbrowser.open(url)
                if self.log_callback: self.log_callback(f"Abrindo navegador: {url}", "NAV")
        else:
            event.Skip()
    
    def on_grid_motion(self, event):
        """Muda o cursor para Hand se estiver sobre a coluna de Link."""
        x, y = event.GetPosition()
        unscrolled_x, unscrolled_y = self.grid.CalcUnscrolledPosition(x, y)
        
        row = self.grid.YToRow(unscrolled_y)
        col = self.grid.XToCol(unscrolled_x)
        
        if col == 2 and row >= 0:
            self.grid.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        else:
            self.grid.SetCursor(wx.NullCursor)
        
        event.Skip()

    def on_header_click(self, event):
        if event.GetCol() == 0:
            rows = self.grid.GetNumberRows()
            if rows == 0: return
            
            current = self.grid.GetCellValue(0, 0)
            new_val = "1" if current == "0" else "0"
            
            for i in range(rows):
                self.grid.SetCellValue(i, 0, new_val)
            
            self.grid.ForceRefresh()
        else:
            event.Skip()

    def get_selected_ids(self):
        ids = []
        rows = self.grid.GetNumberRows()
        for i in range(rows):
            val = self.grid.GetCellValue(i, 0)
            if val == "1":
                if i in self.row_map:
                    ids.append(self.row_map[i])
        return ids

    def _safe_get_video_data(self, video_id):
        """Busca dados atualizados do DB usando get_all_videos (ineficiente mas seguro)."""
        all_videos = self.db_handler.get_all_videos()
        for v in all_videos:
            if str(v['id']) == str(video_id):
                return v
        return None

    # --- Actions ---

    def on_click_process(self, event):
        raw_text = self.txt_input.GetValue()
        if not raw_text.strip():
            wx.MessageBox("Cole pelo menos uma URL.", "Aviso", wx.ICON_WARNING)
            return
            
        self.lbl_status.SetLabel("Enfileirando...")
        self.processor.add_urls(raw_text)
        self.txt_input.Clear()
        if self.log_callback: self.log_callback("Iniciando processamento de URLs.", "INFO")

    # --- Novos Eventos do Processor ---

    def on_task_queued(self, task_uuid, url):
        """Nova tarefa adicionada: cria linha instantânea na grid."""
        self.grid.AppendRows(1)
        row = self.grid.GetNumberRows() - 1
        
        self.row_map[row] = task_uuid
        
        self.grid.SetCellValue(row, 0, "0")                         
        self.grid.SetCellValue(row, 1, "...")                       
        self.grid.SetCellValue(row, 2, url)                         
        self.grid.SetCellTextColour(row, 2, wx.BLUE) # Blue Link
        
        self.grid.SetCellValue(row, 3, "Aguardando...")             
        self.grid.SetCellValue(row, 10, "Na Fila")                   
        
        for c in range(1, 11):
            self.grid.SetReadOnly(row, c, True)
            
        self.grid.ForceRefresh()

    def on_task_started(self, task_uuid):
        row = self._find_row_by_id(task_uuid)
        if row is not None:
             self.grid.SetCellValue(row, 10, "Baixando...")

    def on_metadata_fetched(self, task_uuid, video_id, title):
        row = self._find_row_by_id(task_uuid)
        if row is not None:
            self.grid.SetCellValue(row, 1, str(video_id))
            self.grid.SetCellValue(row, 3, title)
            
            # Atualiza mapa para usar ID real
            self.row_map[row] = video_id

    def on_task_update(self, video_id, status):
        row = self._find_row_by_id(video_id)
        if row is not None:
            self.grid.SetCellValue(row, 10, status)
        else:
            self.lbl_status.SetLabel(f"[{video_id}] {status}")

    def on_task_complete(self, data):
        self.lbl_status.SetLabel(f"Concluído: {data['title']}")
        if self.log_callback: self.log_callback(f"Concluído: {data['title']}", "SUCCESS")
        
        # PERSISTENCE FIX: NÃO usar load_data, apenas update in-place
        row = self._find_row_by_id(data['id'])
        
        # Buscar dados atualizados
        video_record = self._safe_get_video_data(data['id'])
        
        if row is not None and video_record:
            self.grid.SetCellValue(row, 10, "completed")
            
            # Update Tokens & Custo & Duration final
            t = video_record.get('token_count', 0)
            cost = t * 0.000005
            
            # Update other new fields just in case
            self.grid.SetCellValue(row, 4, video_record.get('channel_name') or "-")
            
            # Format date again
            raw_date = video_record.get('upload_date') or ""
            if len(raw_date) == 8 and raw_date.isdigit():
                 formatted_date = f"{raw_date[6:8]}/{raw_date[4:6]}/{raw_date[0:4]}"
                 self.grid.SetCellValue(row, 5, formatted_date)
            else:
                 self.grid.SetCellValue(row, 5, raw_date)


            self.grid.SetCellValue(row, 8, str(t))
            self.grid.SetCellValue(row, 9, f"{cost:.4f}")
            self.grid.SetCellValue(row, 7, str(video_record.get('duration', 0)))
            
            # Reseta cor se estava em erro antes
            self.grid.SetCellTextColour(row, 10, wx.BLACK)
            
            self.grid.ForceRefresh()
        else:
            # Se não achou a linha, loga erro mas não recarrega para não quebrar fluxo
             if self.log_callback: self.log_callback(f"Erro Visual: Linha não encontrada para ID {data['id']}", "WARN")

        # Notifica listeners, mas cuidado para que listeners não chamem load_data!
        if self.on_data_changed: self.on_data_changed()
        
    def on_task_error(self, video_id, error_msg):
        row = self._find_row_by_id(video_id)
        if row is not None:
            self.grid.SetCellValue(row, 10, "ERROR")
            self.grid.SetCellTextColour(row, 10, wx.RED) # RED status
            
        self.lbl_status.SetLabel(f"Erro [{video_id}]: {error_msg}")
        if self.log_callback: self.log_callback(f"Erro [{video_id}]: {error_msg}", "ERROR")

    def _find_row_by_id(self, target_id):
        for row, vid in self.row_map.items():
            if str(vid) == str(target_id):
                return row
        return None

    def on_delete_selected(self, event):
        ids = self.get_selected_ids()
        if not ids:
            wx.MessageBox("Selecione itens usando as caixas de seleção [ ] na primeira coluna.", "Aviso")
            return
            
        dlg = wx.MessageDialog(self, f"Tem certeza que deseja excluir {len(ids)} vídeos?", "Confirmar Exclusão", wx.YES_NO | wx.ICON_WARNING)
        if dlg.ShowModal() != wx.ID_YES:
            dlg.Destroy()
            return
        dlg.Destroy()

        rows_to_delete = []
        for i in range(self.grid.GetNumberRows()):
             if self.grid.GetCellValue(i, 0) == "1":
                 rows_to_delete.append(i)
        
        for r in sorted(rows_to_delete, reverse=True):
            if self.grid.DeleteRows(r, 1):
                pass
        
        for video_id in ids:
            self.db_handler.delete_video(video_id)
            
        # Aqui podemos recarregar, pois deletar muda indices e é uma ação destrutiva controlada
        self.load_data()
        
        if self.on_data_changed:
            self.on_data_changed()

    def on_export(self, event):
        ids = self.get_selected_ids()
        if not ids:
            wx.MessageBox("Selecione itens usando as caixas de seleção [ ] na primeira coluna.", "Aviso")
            return
        
        zip_path = self.processor.export_data(ids, "markdown")
        if zip_path:
            msg = f"Exportação salva em: {zip_path}"
            wx.MessageBox(msg, "Sucesso")
            if self.log_callback: self.log_callback(msg, "INFO")
            import subprocess
            subprocess.Popen(f'explorer /select,"{zip_path}"')
