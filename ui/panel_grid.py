# contextflow/ui/panel_grid.py
import wx
import wx.grid
import webbrowser
from core.processor import Processor
from storage.db_handler import DatabaseHandler

class GridPanel(wx.Panel):
    def __init__(self, parent, on_data_changed=None, log_callback=None):
        super().__init__(parent)
        self.on_data_changed = on_data_changed
        self.log_callback = log_callback
        self.db_handler = DatabaseHandler()
        
        # Processor
        self.processor = Processor()
        self.processor.on_task_update = self.on_task_update
        self.processor.on_task_complete = self.on_task_complete
        self.processor.on_error = self.on_task_error
        
        # Novos Eventos
        self.processor.on_task_queued = self.on_task_queued
        self.processor.on_task_started = self.on_task_started
        self.processor.on_metadata_fetched = self.on_metadata_fetched
        
        self.processor.start_processing() 
        
        # Mapping row -> video_id (or uuid) for easy access
        self.row_map = {} 
        
        self._init_ui()
        self.load_data()

    def _init_ui(self):
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        
        # 1. Headline
        lbl_head = wx.StaticText(self, label="Dashboard (Excel View)")
        font = lbl_head.GetFont()
        font.SetPointSize(12)
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        lbl_head.SetFont(font)
        main_sizer.Add(lbl_head, 0, wx.ALL, 10)

        # 2. Input Area
        input_sizer = wx.StaticBoxSizer(wx.VERTICAL, self, "Adicionar URLs (Youtube Vídeo ou Playlist)")
        self.txt_input = wx.TextCtrl(self, style=wx.TE_MULTILINE, size=(-1, 60))
        input_sizer.Add(self.txt_input, 1, wx.EXPAND | wx.ALL, 5)
        
        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.btn_process = wx.Button(self, label="Processar Fila", size=(200, 40))
        self.btn_process.Bind(wx.EVT_BUTTON, self.on_click_process)
        
        self.btn_clear_input = wx.Button(self, label="Limpar")
        self.btn_clear_input.Bind(wx.EVT_BUTTON, lambda e: self.txt_input.Clear())

        btn_sizer.Add(self.btn_process, 0, wx.RIGHT, 5) 
        btn_sizer.Add(self.btn_clear_input, 0, wx.ALIGN_CENTER_VERTICAL)
        
        input_sizer.Add(btn_sizer, 0, wx.EXPAND | wx.ALL, 5)
        main_sizer.Add(input_sizer, 0, wx.EXPAND | wx.ALL, 5)

        # 3. Grid Table
        self.grid = wx.grid.Grid(self)
        self.grid.CreateGrid(0, 11) # Rows autogenerated, 11 Cols
        
        # Col Headers
        cols = [" [x] ", "ID", "Link", "Título", "Canal", "Publicado", "Playlist", "Duração", "Tokens", "Custo ($)", "Status"]
        for i, col in enumerate(cols):
            self.grid.SetColLabelValue(i, col)
            
        # Configurar tipos de colunas
        self.grid.SetColFormatBool(0) # Checkbox
        
        # Tamanhos
        self.grid.SetColSize(0, 40)
        self.grid.SetColSize(1, 80) # ID
        self.grid.SetColSize(2, 200) # Link
        self.grid.SetColSize(3, 300) # Title
        self.grid.SetColSize(4, 150) # Channel (New)
        self.grid.SetColSize(5, 100) # Published (New)
        self.grid.SetColSize(6, 150) # PL
        self.grid.SetColSize(7, 70) # Duration
        
        # Eventos Grid
        self.grid.Bind(wx.grid.EVT_GRID_LABEL_LEFT_CLICK, self.on_header_click)
        self.grid.Bind(wx.grid.EVT_GRID_CELL_LEFT_CLICK, self.on_cell_click)
        
        # Mouse Motion para cursor "Hand"
        self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.on_grid_motion)
        
        main_sizer.Add(self.grid, 1, wx.EXPAND | wx.ALL, 5)
        
        # 4. Footer Actions
        action_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.btn_delete = wx.Button(self, label="Excluir Selecionados")
        self.btn_delete.Bind(wx.EVT_BUTTON, self.on_delete_selected)
        
        self.btn_export = wx.Button(self, label="Exportar Selecionados (ZIP)")
        self.btn_export.Bind(wx.EVT_BUTTON, self.on_export)
        
        self.lbl_status = wx.StaticText(self, label="Pronto.")
        
        action_sizer.Add(self.lbl_status, 1, wx.ALIGN_CENTER_VERTICAL)
        action_sizer.Add(self.btn_delete, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 5)
        action_sizer.Add(self.btn_export, 0, wx.ALIGN_CENTER_VERTICAL)
        
        main_sizer.Add(action_sizer, 0, wx.EXPAND | wx.ALL, 5)
        
        self.SetSizer(main_sizer)

    def load_data(self):
        """Carrega dados do banco de forma NÃO-DESTRUTIVA (Life Raft Strategy)."""
        
        # 1. Life Raft: Salvar tarefas ativas (que não estão no DB ainda)
        active_tasks = []
        rows = self.grid.GetNumberRows()
        
        for i in range(rows):
            # Identificar status
            status = self.grid.GetCellValue(i, 10)
            if status in ["Na Fila", "Baixando...", "Processando", "Aguardando..."]:
                # Capturar dados vitais para restaurar
                # Assumimos que row_map guarda o UUID/ID desta linha
                uuid = self.row_map.get(i)
                if uuid:
                     task_data = {
                         'uuid': uuid,
                         'url': self.grid.GetCellValue(i, 2),
                         'title': self.grid.GetCellValue(i, 3),
                         'status': status,
                         'channel': self.grid.GetCellValue(i, 4),
                         # Se precisar de outros campos, adicione aqui
                     }
                     active_tasks.append(task_data)
        
        # 2. Limpar Grid
        if rows > 0:
            self.grid.DeleteRows(0, rows)
        
        self.row_map = {}
            
        # 3. Carregar do Banco
        videos = self.db_handler.get_all_videos()
        videos.sort(key=lambda x: x['created_at'], reverse=True)
        
        # 4. Combinar: Ativas primeiro (Topo) ou Último?
        # Usuário pediu para manter. Vamos colocar no topo para visibilidade.
        
        total_rows = len(active_tasks) + len(videos)
        self.grid.AppendRows(total_rows)
        
        current_row = 0
        
        # 4.1 Reinsere Ativas
        for task in active_tasks:
            self.row_map[current_row] = task['uuid']
            
            self.grid.SetCellValue(current_row, 0, "0")
            self.grid.SetCellValue(current_row, 1, "...")
            self.grid.SetCellValue(current_row, 2, task['url'])
            self.grid.SetCellTextColour(current_row, 2, wx.BLUE)
            self.grid.SetCellValue(current_row, 3, task['title'])
            self.grid.SetCellValue(current_row, 4, task.get('channel', '-'))
            self.grid.SetCellValue(current_row, 10, task['status'])
            
            # ReadOnly
            for c in range(1, 11):
                self.grid.SetReadOnly(current_row, c, True)
                
            current_row += 1
            
        # 4.2 Insere DB
        for v in videos:
            self.row_map[current_row] = v['id']
            
            self.grid.SetCellValue(current_row, 0, "0")
            self.grid.SetCellValue(current_row, 1, str(v['id']))
            
            url = v.get('url', '')
            self.grid.SetCellValue(current_row, 2, url)
            if url: self.grid.SetCellTextColour(current_row, 2, wx.BLUE)
            
            self.grid.SetCellValue(current_row, 3, v['title'] or "Sem Título")
            self.grid.SetCellValue(current_row, 4, v.get('channel_name') or "-")

            raw_date = v.get('upload_date') or ""
            if len(raw_date) == 8 and raw_date.isdigit():
                formatted_date = f"{raw_date[6:8]}/{raw_date[4:6]}/{raw_date[0:4]}"
                self.grid.SetCellValue(current_row, 5, formatted_date)
            else:
                self.grid.SetCellValue(current_row, 5, raw_date)

            self.grid.SetCellValue(current_row, 6, v.get('playlist_title') or "-")
            
            d = v.get('duration')
            self.grid.SetCellValue(current_row, 7, str(d) if d else "0")
            
            t = v.get('token_count') or 0
            self.grid.SetCellValue(current_row, 8, str(t))
            
            cost = t * 0.000005
            self.grid.SetCellValue(current_row, 9, f"{cost:.4f}")
            
            status = v.get('status', 'pending')
            self.grid.SetCellValue(current_row, 10, status)
            if status == "ERROR":
                 self.grid.SetCellTextColour(current_row, 10, wx.RED)
            else:
                 self.grid.SetCellTextColour(current_row, 10, wx.BLACK)
            
            for c in range(1, 11):
                self.grid.SetReadOnly(current_row, c, True)
            
            current_row += 1

    def _rebuild_row_map(self):
        """Reconstrói o mapa de linhas baseado no estado atual da grid.
           Nota: Isso assume que o ID não está na grid visível, o que é um problema.
           MELHOR: Não deletar row_map, mas ajustá-lo.
           OU: Apenas confiar que remove_items faz o trabalho sujo corretamente.
           
           Na verdade, o row_map mapeia INDICE -> ID. Se deletarmos linhas, os índices mudam.
           Portanto, PRECISAMOS reconstruir. Mas como saber o ID da linha 5 se o mapa diz que ele era da linha 6?
           
           Solução: O mapa deve ser ajustado no momento da deleção.
        """
        pass # Implementado dentro de remove_items

    def remove_items(self, ids_to_remove):
        """Remove itens da grid de forma cirúrgica, sem reload."""
        if not ids_to_remove: return
        
        # Encontrar linhas para remover
        rows_to_delete = []
        for row, vid in self.row_map.items():
            if str(vid) in [str(x) for x in ids_to_remove]:
                rows_to_delete.append(row)
        
        # Importante: Deletar de baixo para cima
        rows_to_delete.sort(reverse=True)
        
        for r in rows_to_delete:
            self.grid.DeleteRows(r, 1)
            
        # CRITICAL: Rebuild Map because indices shifted
        # Como as linhas mudaram de lugar, o row_map antigo está inválido.
        # Estrategia:
        # 1. Antes de apagar, criar uma lista ordenada de (ID) que SOBRARAM
        remaining_ids = []
        
        # A ordem das linhas não muda, apenas "sobe".
        # Então podemos iterar pelos INDICES antigos ordenados.
        MAX_ROWS_BEFORE = self.grid.GetNumberRows() + len(rows_to_delete)
        
        # Vamos fazer diferente: vamos salvar a lista de IDs na ordem visual atual
        # Exceto os que vamos apagar.
        
        final_list = []
        for r in range(MAX_ROWS_BEFORE):
            # Se r estava no map
            vid = self.row_map.get(r)
            if vid:
                # Se não é para deletar
                should_delete = False
                if str(vid) in [str(x) for x in ids_to_remove]:
                     should_delete = True
                
                if not should_delete:
                    final_list.append(vid)
        
        # Agora o final_list tem os IDs na ordem que a grid ficou.
        # Atualizamos o map
        self.row_map = {}
        for i, vid in enumerate(final_list):
            self.row_map[i] = vid

        self.grid.ForceRefresh()

    def on_cell_click(self, event):
        row = event.GetRow()
        col = event.GetCol()
        
        # 1. Clique único no Checkbox
        if col == 0:
            val = self.grid.GetCellValue(row, 0)
            new_val = "1" if val == "0" else "0"
            self.grid.SetCellValue(row, 0, new_val)
            self.grid.ForceRefresh() 
            
        # 2. Clique no Link
        elif col == 2:
            url = self.grid.GetCellValue(row, 2)
            if url.startswith("http"):
                webbrowser.open(url)
                if self.log_callback: self.log_callback(f"Abrindo navegador: {url}", "NAV")
        else:
            event.Skip()
    
    def on_grid_motion(self, event):
        """Muda o cursor para Hand se estiver sobre a coluna de Link."""
        x, y = event.GetPosition()
        unscrolled_x, unscrolled_y = self.grid.CalcUnscrolledPosition(x, y)
        
        row = self.grid.YToRow(unscrolled_y)
        col = self.grid.XToCol(unscrolled_x)
        
        if col == 2 and row >= 0:
            self.grid.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        else:
            self.grid.SetCursor(wx.NullCursor)
        
        event.Skip()

    def on_header_click(self, event):
        if event.GetCol() == 0:
            rows = self.grid.GetNumberRows()
            if rows == 0: return
            
            current = self.grid.GetCellValue(0, 0)
            new_val = "1" if current == "0" else "0"
            
            for i in range(rows):
                self.grid.SetCellValue(i, 0, new_val)
            
            self.grid.ForceRefresh()
        else:
            event.Skip()

    def get_selected_ids(self):
        ids = []
        rows = self.grid.GetNumberRows()
        for i in range(rows):
            val = self.grid.GetCellValue(i, 0)
            if val == "1":
                if i in self.row_map:
                    ids.append(self.row_map[i])
        return ids

    def _safe_get_video_data(self, video_id):
        """Busca dados atualizados do DB usando get_all_videos (ineficiente mas seguro)."""
        all_videos = self.db_handler.get_all_videos()
        for v in all_videos:
            if str(v['id']) == str(video_id):
                return v
        return None

    # --- Actions ---

    def on_click_process(self, event):
        raw_text = self.txt_input.GetValue()
        if not raw_text.strip():
            wx.MessageBox("Cole pelo menos uma URL.", "Aviso", wx.ICON_WARNING)
            return
            
        self.lbl_status.SetLabel("Enfileirando...")
        self.processor.add_urls(raw_text)
        self.txt_input.Clear()
        if self.log_callback: self.log_callback("Iniciando processamento de URLs.", "INFO")

    # --- Novos Eventos do Processor ---

    def on_task_queued(self, task_uuid, url):
        """Nova tarefa adicionada: cria linha instantânea na grid."""
        self.grid.AppendRows(1)
        row = self.grid.GetNumberRows() - 1
        
        self.row_map[row] = task_uuid
        
        self.grid.SetCellValue(row, 0, "0")                         
        self.grid.SetCellValue(row, 1, "...")                       
        self.grid.SetCellValue(row, 2, url)                         
        self.grid.SetCellTextColour(row, 2, wx.BLUE) # Blue Link
        
        self.grid.SetCellValue(row, 3, "Aguardando...")             
        self.grid.SetCellValue(row, 10, "Na Fila")                   
        
        for c in range(1, 11):
            self.grid.SetReadOnly(row, c, True)
            
        self.grid.ForceRefresh()

    def on_task_started(self, task_uuid):
        row = self._find_row_by_id(task_uuid)
        if row is not None:
             self.grid.SetCellValue(row, 10, "Baixando...")

    def on_metadata_fetched(self, task_uuid, video_id, title):
        row = self._find_row_by_id(task_uuid)
        
        if row is None:
             # Self-Healing: Create row if missing
             self.grid.AppendRows(1)
             row = self.grid.GetNumberRows() - 1
             # We need to map it
             self.row_map[row] = task_uuid
             
             # Fill basic info we have
             self.grid.SetCellValue(row, 0, "0")
             self.grid.SetCellValue(row, 1, str(video_id))
             self.grid.SetCellValue(row, 3, title)
             self.grid.SetCellValue(row, 10, "Baixando...") # Assoc with active
             
             for c in range(1, 11):
                 self.grid.SetReadOnly(row, c, True)
                 
             if self.log_callback: self.log_callback(f"Grid Self-Healed: Row recreated for {video_id}", "WARN")

        if row is not None:
            self.grid.SetCellValue(row, 1, str(video_id))
            self.grid.SetCellValue(row, 3, title)
            
            # Atualiza mapa para usar ID real
            self.row_map[row] = video_id

    def on_task_update(self, video_id, status):
        row = self._find_row_by_id(video_id)
        if row is not None:
            self.grid.SetCellValue(row, 10, status)
        else:
            self.lbl_status.SetLabel(f"[{video_id}] {status}")

    def on_task_complete(self, data):
        self.lbl_status.SetLabel(f"Concluído: {data['title']}")
        if self.log_callback: self.log_callback(f"Concluído: {data['title']}", "SUCCESS")
        
        # PERSISTENCE FIX: NÃO usar load_data, apenas update in-place
        row = self._find_row_by_id(data['id'])
        
        # Buscar dados atualizados
        video_record = self._safe_get_video_data(data['id'])
        
        if row is not None and video_record:
            self.grid.SetCellValue(row, 10, "completed")
            
            # Update Tokens & Custo & Duration final
            t = video_record.get('token_count', 0)
            cost = t * 0.000005
            
            # Update other new fields just in case
            self.grid.SetCellValue(row, 4, video_record.get('channel_name') or "-")
            
            # Format date again
            raw_date = video_record.get('upload_date') or ""
            if len(raw_date) == 8 and raw_date.isdigit():
                 formatted_date = f"{raw_date[6:8]}/{raw_date[4:6]}/{raw_date[0:4]}"
                 self.grid.SetCellValue(row, 5, formatted_date)
            else:
                 self.grid.SetCellValue(row, 5, raw_date)


            self.grid.SetCellValue(row, 8, str(t))
            self.grid.SetCellValue(row, 9, f"{cost:.4f}")
            self.grid.SetCellValue(row, 7, str(video_record.get('duration', 0)))
            
            # Reseta cor se estava em erro antes
            self.grid.SetCellTextColour(row, 10, wx.BLACK)
            
            self.grid.ForceRefresh()
        else:
            # Se não achou a linha, loga erro mas não recarrega para não quebrar fluxo
             if self.log_callback: self.log_callback(f"Erro Visual: Linha não encontrada para ID {data['id']}", "WARN")

        # Notifica listeners, mas cuidado para que listeners não chamem load_data!
        if self.on_data_changed: self.on_data_changed()
        
    def on_task_error(self, video_id, error_msg):
        row = self._find_row_by_id(video_id)
        if row is not None:
            self.grid.SetCellValue(row, 10, "ERROR")
            self.grid.SetCellTextColour(row, 10, wx.RED) # RED status
            
        self.lbl_status.SetLabel(f"Erro [{video_id}]: {error_msg}")
        if self.log_callback: self.log_callback(f"Erro [{video_id}]: {error_msg}", "ERROR")

    def _find_row_by_id(self, target_id):
        for row, vid in self.row_map.items():
            if str(vid) == str(target_id):
                return row
        return None

    def on_delete_selected(self, event):
        ids = self.get_selected_ids()
        if not ids:
            wx.MessageBox("Selecione itens usando as caixas de seleção [ ] na primeira coluna.", "Aviso")
            return
            
        dlg = wx.MessageDialog(self, f"Tem certeza que deseja excluir {len(ids)} vídeos?", "Confirmar Exclusão", wx.YES_NO | wx.ICON_WARNING)
        if dlg.ShowModal() != wx.ID_YES:
            dlg.Destroy()
            return
        dlg.Destroy()

        rows_to_delete = []
        for i in range(self.grid.GetNumberRows()):
             if self.grid.GetCellValue(i, 0) == "1":
                 rows_to_delete.append(i)
        
        for r in sorted(rows_to_delete, reverse=True):
            if self.grid.DeleteRows(r, 1):
                pass
        
        for video_id in ids:
            self.db_handler.delete_video(video_id)
            
        # Aqui podemos recarregar, pois deletar muda indices e é uma ação destrutiva controlada
        self.load_data()
        
        if self.on_data_changed:
            self.on_data_changed()

    def on_export(self, event):
        ids = self.get_selected_ids()
        if not ids:
            wx.MessageBox("Selecione itens usando as caixas de seleção [ ] na primeira coluna.", "Aviso")
            return
        
        zip_path = self.processor.export_data(ids, "markdown")
        if zip_path:
            msg = f"Exportação salva em: {zip_path}"
            wx.MessageBox(msg, "Sucesso")
            if self.log_callback: self.log_callback(msg, "INFO")
            import subprocess
            subprocess.Popen(f'explorer /select,"{zip_path}"')
